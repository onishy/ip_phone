/* 
 * fft.c
 * 使い方
 *   ./fft n
 * 
 * 以下を繰り返す:
 *   標準入力から, 16 bit integerをn個読む
 *   FFTする
 *   逆FFTする
 *   標準出力へ出す
 *
 * したがって「ほぼ何もしない」フィルタになる
 * 
 */
#include <assert.h>
#include <complex.h>
#include <math.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define SAMPLING_F 44100

typedef short sample_t;

void die(char * s) {
  perror(s); 
  exit(1);
}

/* fd から 必ず n バイト読み, bufへ書く.
   n バイト未満でEOFに達したら, 残りは0で埋める.
   fd から読み出されたバイト数を返す */
ssize_t read_n(int fd, ssize_t n, void * buf) {
  ssize_t re = 0;
  while (re < n) {
    ssize_t r = read(fd, buf + re, n - re);
    if (r == -1) die("read");
    if (r == 0) break;
    re += r;
  }
  memset(buf + re, 0, n - re);
  return re;
}

/* fdへ, bufからnバイト書く */
ssize_t write_n(int fd, ssize_t n, void * buf) {
  ssize_t wr = 0;
  while (wr < n) {
    ssize_t w = write(fd, buf + wr, n - wr);
    if (w == -1) die("write");
    wr += w;
  }
  return wr;
}

/* 標本(整数)を複素数へ変換 */
void sample_to_complex(sample_t * s, 
		       complex double * X, 
		       long n) {
  long i;
  for (i = 0; i < n; i++) X[i] = s[i];
}

/* 複素数を標本(整数)へ変換. 虚数部分は無視 */
void complex_to_sample(complex double * X, 
		       sample_t * s, 
		       long n) {
  long i;
  for (i = 0; i < n; i++) {
    s[i] = creal(X[i]);
  }
}

/* 高速(逆)フーリエ変換;
   w は1のn乗根.
   フーリエ変換の場合   偏角 -2 pi / n
   逆フーリエ変換の場合 偏角  2 pi / n
   xが入力でyが出力.
   xも破壊される
 */
void fft_r(complex double * x, 
	   complex double * y, 
	   long n, 
	   complex double w) {
  if (n == 1) { y[0] = x[0]; }
  else {
    complex double W = 1.0; 
    long i;
    for (i = 0; i < n/2; i++) {
      y[i]     =     (x[i] + x[i+n/2]); /* 偶数行 */
      y[i+n/2] = W * (x[i] - x[i+n/2]); /* 奇数行 */
      W *= w;
    }
    fft_r(y,     x,     n/2, w * w);
    fft_r(y+n/2, x+n/2, n/2, w * w);
    for (i = 0; i < n/2; i++) {
      y[2*i]   = x[i];
      y[2*i+1] = x[i+n/2];
    }
  }
}

void fft(complex double * x, 
	 complex double * y, 
	 long n) {
  long i;
  double arg = 2.0 * M_PI / n;
  complex double w = cos(arg) - 1.0j * sin(arg);
  fft_r(x, y, n, w);
  for (i = 0; i < n; i++) {
    y[i] /= n;
//    printf("%ld: %f\n", i, cabs(y[i]));
  }
}

void ifft(complex double * y, 
	  complex double * x, 
	  long n) {
  double arg = 2.0 * M_PI / n;
  complex double w = cos(arg) + 1.0j * sin(arg);
  fft_r(y, x, n, w);
}

void bpf(complex double *y, long n, long smpl_f, long min_l, long max_l) {
  long i = 0;
  for(i = 0; i < min_l; i++) {
    y[i] = 0;
    y[i + n/2] = 0;
  }
  for(i = max_l+1; i < n/2; i++) {
    y[i] = 0;
    y[i + n/2] = 0;
  }
}

int pow2check(long N) {
  long n = N;
  while (n > 1) {
    if (n % 2) return 0;
    n = n / 2;
  }
  return 1;
}

int main(int argc, char ** argv) {
  if(argc != 4) {
    printf("UNCHI!!!!!\n");
    exit(1);
  }

  long n = atol(argv[1]);
  if (!pow2check(n)) {
    fprintf(stderr, "error : n (%ld) not a power of two\n", n);
    exit(1);
  }

  double min_f = atof(argv[2]);
  double max_f = atof(argv[3]);

  double smpl_f = SAMPLING_F;

  long min_l = (long)(min_f * n / (double)smpl_f);
  long max_l = (long)(max_f * n / (double)smpl_f);

  if(min_f > max_f || min_f < 0 || min_l > n/2 || max_l > n/2) {
    printf("max or min frequency out of range\n");
    exit(1);
  }

  // int min_l = (int)(min_f * n);
  // int max_l = (int)(max_f * n);

  sample_t * buf = calloc(sizeof(sample_t), n);
  complex double * X = calloc(sizeof(complex double), n);
  complex double * Y = calloc(sizeof(complex double), n);
  complex double * Z = calloc(sizeof(complex double), n);
  while (1) {
    /* 標準入力からn個標本を読む */
    ssize_t m = read_n(0, n * sizeof(sample_t), buf);
    if (m == 0) break;
    /* 複素数の配列に変換 */
    sample_to_complex(buf, X, n);
    /* FFT -> Y */
    fft(X, Y, n);

    int i;
   const double pitch = 2;
    for(i = 0; i < n/2; i++) {
//      if(i*pitch > n/2) break;
      Z[(int)(i*pitch)] = Y[i];
      Z[(int)(n-1-i*pitch)] = Y[n-1-i];

//      if(i > 0) {
//        int j = 0;
//        double slope_r = (Y[i] - Y[i-1])/pitch;
//        double slope_i = (Y[n-1-i] - Y[n-i])/pitch;
//        for(j = (int)((i-1)*pitch)+1; j < (int)(i*pitch); j++) {
//          Z[j] = Z[j-1] + slope_r;
//          Z[n-1-j] = Z[n-j] + slope_i;
//        }
//      }
    }
    // double factor = 1.001;
    // for(i = 0; i < n/2; i++) {
    //   if(cabsf(Y[i]) > 10) {
    //     Z[i] = Y[i] * 5;
    //     Z[i+n/2] = Y[i+n/2] * 5;
    //   } else {
    //     Z[i] = Y[i];
    //     Z[i+n/2] = Y[i+n/2];        
    //   }
      // Z[(int)(i*factor)] = Y[i];
      // Z[(int)(i*factor+n/2)] = Y[i+n/2];
    // }
    /* IFFT -> Z */
    ifft(Z, X, n);
    /* 標本の配列に変換 */
    complex_to_sample(X, buf, n);
    /* 標準出力へ出力 */
    write_n(1, m, buf);
  }
  return 0;
}
